<?php 

namespace Divergent\Films\Core\Database;

use Divergent\Films\Core\Render\Render;

use Divergent\Films\Core\Database\Query\Interfaces\Query as IQuery;
use Divergent\Films\Core\Database\Query;
use Divergent\Films\Core\Database\Query\Select;

/**
 * 
 */
abstract class Model {

    /**
     * @var string $table_name The table name. Can be generated by a child class name.
     */
    protected static string $table_name = '';

    /**
     * @var array $fillable The list of fields which can to be modified.
     */
    protected array $fillable;

    /**
     * @var array $data Data of the single model row.
     */
    protected array $data;

    /**
     * @var IQuery $query Object of a class which implements the Query interface.
     */
    private IQuery $query;

    protected function __construct (array $data = []) {
        $this->data = $data;
    }

    /**
     * Return or generate and return the table name.
     * 
     * @return string Table name
     */
    protected static function table_name (): string {
        if (empty(static::$table_name)) {
            return preg_replace('#^.+\\\\(.+?)$#si', '$1', static::class) . 's';
        }

        return static::$table_name;
    }

    /**
     * Count of all table rows.
     * 
     * @return int Total count
     */
    public static function count (): int {
        return (int) self::query(
            'SELECT count(*) as count FROM `' . self::table_name() . '`'
        )[0]['count'];
    }

    public function __set (string $name, mixed $value) {
        $this->data[$name] = $value;
    }

    public function __get (string $name) {
        if (isset($this->data[$name])) {
            return $this->data[$name];
        }

        return null;
    }

    /**
     * Proxy for query intarface.
     */
    public function __call (string $name, array $arguments): static {
        if (method_exists($this->query, $name)) {
            call_user_func_array(
                [$this->query, $name], 
                $arguments
            );

            return $this;
        }
    }

    /**
     * Selecting all rows from the table.
     * 
     * @return static Builder of a query.
     */
    public static function all (): static {
        $builder = new static();
        $builder->query = Query::select()
            ->from(static::table_name());

        return $builder;
    }

    /**
     * Pagination over a Model.
     * 
     * @param int $per_page Models count per one page.
     * @param int $page Current page. If not set - will get from the $_GET array.
     * 
     * @return static Builder of a query.
     */
    public static function paginate (
        int $per_page = 10, 
        int $page = null
    ): static {
        if ($per_page === 0) return [];

        if ($page === null) {
            if (isset($_GET['page']) && is_numeric($_GET['page'])) {
                $page = (int) $_GET['page'];
            } else {
                $page = 1;
            }
        }

        $offset = $per_page * ($page - 1);

        $builder = new static();
        $builder->query = Query::select()
            ->from(static::table_name())
            ->limit($per_page)
            ->offset($offset);

        return $builder;
    }

    /**fn (array $row) => ! empty($row)
     * Consume the builder to array of the model objects.
     * 
     * @return array Array of the model objects.
     */
    public function get (): array {
        if (! $this->query instanceof Select) [];

        return self::map_to_object(
            static::query(
                $this->query->build()
            )
        );
    }

    /**
     * Rendering the pagination for the Model
     * 
     * @param int $per_page = 10. Count of object at one page.
     * @param int $page = null. Current page number.
     * @param string $url = null. Url for map URL.
     * 
     * @return string HTML code of the pagination.
     */
    public static function render_pagination (
        int $per_page = 10, 
        int $page = null, 
        string $url = null
    ): string {
        $total_pages = ceil(static::count() / $per_page);

        // Ignore when one page only
        if ($total_pages < 2) return '';

        // Prepare the current page num.
        if ($page === null) {
            if (isset($_GET['page']) && is_numeric($_GET['page'])) {
                $page = (int) $_GET['page'];
            } else {
                $page = 1;
            }
        }

        // Prepare the current url.
        if ($url === null) {
            $url = $_SERVER['REQUEST_URI'];
        }

        // Parse the current url to url part and a query.
        if (strpos($url, '?')) {
            list ($current_url, $query_string) = explode('?', $url);
        } else {
            $current_url = $url;
            $query_string = '';
        }

        $pages = [];

        // Fill the pages array
        for ($i = 1; $i <= $total_pages; $i++) {
            parse_str($query_string, $query_arr);

            $query_arr['page'] = $i;

            $pages[$i] = [
                'title' => $i,
                'url' => $current_url . '?' . http_build_query($query_arr),
                'active' => false,
                'disabled' => false,
            ];
        }

        // Mark an active page
        foreach ($pages as $i => &$_page) {
            if ($i == $page) {
                $_page['active'] = true;
            }
        }

        // Previous page link
        $previous_page = [
            'title' => 'Previous',
            // If the prev page available - link or #
            'url' => $page === 1 ? '#' : $pages[$page - 1]['url'],
            'active' => false, // Always false
            // If the prev page not available - disabling the link
            'disabled' => $page === 1
        ];

        // Next page link
        $next_page = [
            'title' => 'Next',
            // If the next page available - link or #
            'url' => $page === count($pages) ? '#' : $pages[$page + 1]['url'],
            'active' => false, // Always false
            // If the next page not available - disabling the link
            'disabled' => $page === count($pages)
        ];

        $pages[0] = $previous_page;
        $pages[] = $next_page;

        ksort($pages);

        return Render::view('pagination', compact('pages'));
    }

    /**
     * Map rows from a mysqli_result to a model objects.
     * 
     * @param array $mysql_rows mysqli_result rows.
     * 
     * @return array Array of model objects.
     */
    private static function map_to_object (array $mysql_rows): array {
        return array_map(
            function (array $row) {
                return new static($row);
            },
            array_filter(
                isset($mysql_rows[0]) && is_array($mysql_rows[0]) 
                    ? $mysql_rows 
                    : [$mysql_rows],
                'count'
            )
        );
    }

    /**
     * Search by key and return an object of some Model.
     * 
     * @param mixed $value Value which must be equals.
     * @param string $by Key of the table.
     * 
     * @return static|null Object of a Model
     */
    public static function find (mixed $value, string $by = 'id'): static|null {

        $result = static::query(
            Query::select()
                ->from(static::table_name())
                ->where($by, $value)
                ->build()
        )[0] ?? [];

        if (empty($result)) return null;

        return new static($result);
    }

    /**
     * Select objects of the table by some the where
     * 
     * @param array $param Where conditions.
     * 
     * @return static Builder of a query.
     */
    public static function where (array $params): static {
        $builder = new static();
        $builder->query = Query::select()
            ->from(static::table_name());

        foreach ($params as $key => $value) {
            $builder->query->where($key, $value);
        }

        return $builder;
    }

    /**
     * Delete an object from a table
     * 
     * @return bool True - success deleted. False - failed.
     */
    public function delete (): bool {
        if ($this->id === null) return false;

        static::query(
            Query::delete(static::table_name())
                ->where('id', $this->id)
                ->build()
        );

        return true;
    }

    /**
     * Update an object of the table
     * 
     * @return bool True - success updated. False - failed.
     */
    public function update (): bool {
        if ($this->id === null) {
            return false;
        }

        return static::query(
            Query::update(
                static::table_name(),
                $this->data
            )->where('id', $this->id)
                ->build()
        )['result'];
    }

    /**
     * Insert a new row to the table.
     * 
     * @param array $fields Assoc array of the fields and their values.
     * 
     * @return bool|int ID of new row or false if failed.
     */
    public static function create (array $fields): bool|int {
        global $kernel;

        $insert_id = mysqli_insert_id($kernel->database()->get_connection());
        
        static::query(
            Query::insert(
                static::table_name(),
                $fields
            )->build()
        );

        $new_insert_id = mysqli_insert_id($kernel->database()->get_connection());
        
        if ($insert_id === $new_insert_id) return false;

        return $new_insert_id;
    }

    /**
     * Making a query to the database and parse the result to array
     * 
     * @param string $query The query.
     * 
     * @return array Returning array.
     */
    protected static function query (string $query): array {
        global $kernel;

        $result = [];

        $mysqli_result = $kernel->database()->query($query);

        if (! $mysqli_result instanceof \mysqli_result) {
            return ['result' => $mysqli_result];
        }

        while (($row = mysqli_fetch_assoc($mysqli_result)) !== null) {
            $result[] = $row;
        }

        // if (count($result) === 1) {
        //     return $result[0];
        // }

        return $result;
    }
}